<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Runner</title>
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
                "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/"
            }
        }
    </script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Orbitron', sans-serif;
            background-color: #1a1a1a;
        }
        canvas {
            display: block;
        }
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            color: #00ffff;
            pointer-events: none;
            opacity: 0; /* Hidden by default, fade in with game start */
            transition: opacity 0.5s ease-in-out;
        }
        .top-ui {
            display: flex;
            justify-content: space-between;
            width: 100%;
            padding: 20px;
        }
        #score, #multiplier, #hoverboard-count {
            font-size: 1.5rem;
            padding: 10px 20px;
            background-color: rgba(0,0,0,0.4);
            border-radius: 10px;
            text-shadow: 0 0 5px #00ffff, 0 0 10px #00ffff;
        }
        #hoverboard-status {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.2rem;
            padding: 10px 20px;
            background-color: rgba(29, 161, 242, 0.7);
            border-radius: 10px;
            display: none; /* Hidden by default */
        }
        #game-over-screen, #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.75);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            pointer-events: auto;
        }
        .game-title { 
            font-size: 3rem; 
            margin-bottom: 20px; 
            color: #FFD700; 
            text-shadow: 3px 3px 6px rgba(0,0,0,0.7);
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        .instructions { 
            font-size: 1rem; 
            margin-bottom: 30px; 
            max-width: 90%; 
            line-height: 1.5; 
            color: #00ffff;
            text-shadow: 0 0 5px #00ffff;
        }
        .button { 
            font-family: 'Orbitron', sans-serif; 
            font-size: 1.5rem; 
            padding: 15px 30px; 
            background-color: #FF4500; 
            border: none; 
            color: white; 
            cursor: pointer; 
            border-radius: 10px; 
            box-shadow: 0 5px #B22222; 
            transition: all 0.1s ease-in-out; 
        }
        .button:hover { background-color: #FF6347; }
        .button:active { transform: translateY(5px); box-shadow: 0 0 #B22222; }
        .button:disabled { background-color: #888; cursor: not-allowed; box-shadow: 0 5px #555; }
        #loading-container {
            width: 50%;
            max-width: 400px;
            height: 30px;
            background-color: #333;
            border-radius: 15px;
            overflow: hidden;
            border: 2px solid #555;
            margin-top: 20px;
        }
        #loading-bar {
            width: 0%;
            height: 100%;
            background-color: #FFD700;
            transition: width 0.2s ease-out;
        }
    </style>
</head>
<body>
    <div id="ui-container">
        <div class="top-ui">
            <div id="score">Score: 0</div>
            <div id="hoverboard-count">Hoverboards: 3</div>
            <div id="multiplier">x1</div>
        </div>
        <div id="hoverboard-status"></div>
    </div>
    <div id="start-screen">
        <h1 class="game-title">Run nigga Run</h1>
        <p class="instructions">
            <b>DESKTOP:</b> ARROW KEYS to move, JUMP, and ROLL. 'H' for Hoverboard.<br>
            <b>MOBILE:</b> SWIPE to move, JUMP, and ROLL. DOUBLE-TAP for Hoverboard.
        </p>
        <button id="start-button" class="button" disabled>Loading...</button>
        <div id="loading-container">
            <div id="loading-bar"></div>
        </div>
    </div>
    <div id="game-over-screen" style="display: none;">
        <h1 class="game-title">Game Over !! Hero nind</h1>
        <p id="final-score" class="instructions" style="font-size: 1.5rem;"></p>
        <button id="restart-button" class="button">Restart</button>
    </div>
    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';

        // --- Basic Scene Setup ---
        let scene, camera, renderer, clock, composer;
        let player, playerBoundingBox, chaser, stars;
        let obstacles = [], collectibles = [], sceneryObjects = [], slowdownPatches = [];
        let trackSegments = [];
        let lanes = [-3.5, 0, 3.5];
        let currentLane = 1;
        let gameSpeed = 0.2;
        let score = 0;
        let scoreMultiplier = 1;
        let isGameRunning = false;
        let isIntroAnimating = false;
        let introAnimationTime = 0;

        // --- Player Physics & States ---
        const gravity = -0.03; // Increased gravity for faster fall
        let playerVelocityY = 0;
        let isJumping = false;
        let isRolling = false;
        let rollTimer = 0;
        let isHoverboardActive = false;
        let hoverboardTimer = 0;
        let hoverboardCount = 3;
        let isSlowed = false;
        let slowdownTimer = 0;
        const jumpStrength = 0.45;
        const groundY = 1.3; 

        // --- Touch Controls ---
        let touchStartX = 0, touchStartY = 0;
        let lastTapTime = 0;
        
        // --- Loading Manager ---
        const loadingManager = new THREE.LoadingManager();
        const loadingBar = document.getElementById('loading-bar');
        const startButton = document.getElementById('start-button');
        const loadingContainer = document.getElementById('loading-container');

        loadingManager.onProgress = (url, itemsLoaded, itemsTotal) => {
            loadingBar.style.width = `${(itemsLoaded / itemsTotal) * 100}%`;
        };
        loadingManager.onLoad = () => {
            loadingContainer.style.display = 'none';
            startButton.disabled = false;
            startButton.textContent = 'Start Game';
        };

        function createStarTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        function init() {
            clock = new THREE.Clock();
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x00001a); // Night sky
            scene.fog = new THREE.Fog(0x00001a, 60, 150);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ReinhardToneMapping;
            document.body.appendChild(renderer.domElement);
            
            // --- Post-processing for Glow Effect ---
            const renderScene = new RenderPass( scene, camera );
            const bloomPass = new UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 1.5, 0.4, 0.85 );
            bloomPass.threshold = 0.4;
            bloomPass.strength = 0.6;
            bloomPass.radius = 0.4;
            composer = new EffectComposer( renderer );
            composer.addPass( renderScene );
            composer.addPass( bloomPass );
            
            // --- Lighting ---
            const ambientLight = new THREE.AmbientLight(0x4040ff, 0.3);
            scene.add(ambientLight);
            const hemiLight = new THREE.HemisphereLight(0x4466ff, 0x112233, 0.8);
            scene.add(hemiLight);
            const dirLight = new THREE.DirectionalLight(0xaaaaff, 1.0);
            dirLight.position.set(10, 20, 5);
            dirLight.castShadow = true;
            dirLight.shadow.camera.top = 20;
            dirLight.shadow.camera.bottom = -20;
            dirLight.shadow.camera.left = -20;
            dirLight.shadow.camera.right = 20;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            createStarfield();
            createGround();
            createTrack();
            createPlayer();
            createChaser();
            
            updateHoverboardUI();
            resetCameraToIntro();
            animate();

            // Event Listeners
            document.addEventListener('keydown', handleKeyDown);
            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('touchstart', handleTouchStart, { passive: false });
            renderer.domElement.addEventListener('touchend', handleTouchEnd);
            startButton.addEventListener('click', startGame);
            document.getElementById('restart-button').addEventListener('click', restartGame);
        }
        
        function createStarfield() {
            const vertices = [];
            const colors = [];
            const color = new THREE.Color();
            for ( let i = 0; i < 5000; i ++ ) {
                const x = THREE.MathUtils.randFloatSpread( 2000 );
                const y = THREE.MathUtils.randFloat( 10, 1000 );
                const z = THREE.MathUtils.randFloatSpread( 2000 );
                vertices.push( x, y, z );

                const brightness = Math.random() * 0.5 + 0.5;
                color.setRGB(brightness, brightness, brightness);
                colors.push(color.r, color.g, color.b);
            }
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );
            geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );
            
            const starTexture = createStarTexture();
            const material = new THREE.PointsMaterial({
                map: starTexture,
                size: 5.0,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                vertexColors: true
            });
            
            stars = new THREE.Points( geometry, material );
            scene.add( stars );
        }
        
        function generateRoadTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#333';
            ctx.fillRect(0, 0, 256, 256);
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 4;
            for(let i = 0; i < 4; i++) {
                for(let j = 0; j < 4; j++) {
                    ctx.strokeRect(i * 64, j * 64, 64, 64);
                }
            }
            ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
            for(let i=0; i<100; i++){
                ctx.beginPath();
                ctx.arc(Math.random()*256, Math.random()*256, Math.random()*2, 0, Math.PI*2);
                ctx.fill();
            }
            return new THREE.CanvasTexture(canvas);
        }

        function generateGrassTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const context = canvas.getContext('2d');
            context.fillStyle = '#183818';
            context.fillRect(0, 0, 128, 128);
            for (let i = 0; i < 8000; i++) {
                const x = Math.random() * 128;
                const y = Math.random() * 128;
                context.fillStyle = `rgba(32, ${Math.floor(Math.random() * 30) + 70}, 32, ${Math.random() * 0.5})`;
                context.fillRect(x - 5, y - 5, 10, 10);
                context.strokeStyle = `rgba(80, ${Math.floor(Math.random() * 50) + 120}, 80, 0.7)`;
                context.lineWidth = Math.random() * 0.5 + 0.5;
                context.beginPath();
                context.moveTo(x, y);
                context.lineTo(x + Math.random() * 2 - 1, y - Math.random() * 5 - 2);
                context.stroke();
            }
            return new THREE.CanvasTexture(canvas);
        }

        function createGround() {
            const grassTexture = generateGrassTexture();
            grassTexture.wrapS = THREE.RepeatWrapping;
            grassTexture.wrapT = THREE.RepeatWrapping;
            grassTexture.repeat.set(16, 40);
            const groundGeo = new THREE.PlaneGeometry(100, 250);
            const groundMat = new THREE.MeshStandardMaterial({ map: grassTexture, roughness: 0.9 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.1;
            ground.receiveShadow = true;
            scene.add(ground);
        }
        
        function createTrack() {
            const roadTexture = generateRoadTexture();
            roadTexture.wrapS = THREE.RepeatWrapping;
            roadTexture.wrapT = THREE.RepeatWrapping;
            roadTexture.repeat.set(3, 10);
            const segmentLength = 50;
            const lineMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });

            for (let i = 0; i < 5; i++) {
                const zPos = (i * -segmentLength) + segmentLength/2;
                const trackGeo = new THREE.PlaneGeometry(12, segmentLength);
                const trackMat = new THREE.MeshStandardMaterial({ map: roadTexture, roughness: 0.8 });
                const trackSegment = new THREE.Mesh(trackGeo, trackMat);
                trackSegment.rotation.x = -Math.PI / 2;
                trackSegment.position.z = zPos;
                trackSegment.receiveShadow = true;
                scene.add(trackSegment);
                trackSegments.push(trackSegment);
                const lineGeo = new THREE.PlaneGeometry(0.2, segmentLength);
                const leftLine = new THREE.Mesh(lineGeo, lineMat);
                leftLine.rotation.x = -Math.PI/2;
                leftLine.position.set(-5.9, 0.01, zPos);
                scene.add(leftLine);
                trackSegments.push(leftLine);
                const rightLine = new THREE.Mesh(lineGeo, lineMat);
                rightLine.rotation.x = -Math.PI/2;
                rightLine.position.set(5.9, 0.01, zPos);
                scene.add(rightLine);
                trackSegments.push(rightLine);
            }
        }
        
        function createPlayer() {
            player = new THREE.Group();
            const headGroup = new THREE.Group();
            const textureLoader = new THREE.TextureLoader(loadingManager); // Use loading manager
            const faceTexture = textureLoader.load('https://res.cloudinary.com/dfmhr0tu8/image/upload/v1756477756/nagu-removebg-preview_iq7uil.png');
            const faceMat = new THREE.MeshBasicMaterial({ map: faceTexture, transparent: true });
            const facePlane = new THREE.Mesh(new THREE.PlaneGeometry(0.5, 0.5), faceMat);
            facePlane.position.z = 0.26;
            const headMat = new THREE.MeshStandardMaterial({ color: 0x402820, roughness: 0.8 });
            const headGeo = new THREE.SphereGeometry(0.25, 16, 12);
            headGeo.scale(1, 1.1, 1);
            const head = new THREE.Mesh(headGeo, headMat);
            headGroup.add(head, facePlane);
            const shirtMat = new THREE.MeshStandardMaterial({ color: 0x008080, roughness: 0.7 });
            const pantsMat = new THREE.MeshStandardMaterial({ color: 0x222244, roughness: 0.8 });
            headGroup.position.y = 0.5;
            const torso = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.7, 0.4), shirtMat);
            const leftArm = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.6, 0.2), headMat);
            leftArm.position.set(-0.35, 0, 0);
            const rightArm = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.6, 0.2), headMat);
            rightArm.position.set(0.35, 0, 0);
            const leftLeg = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.7, 0.3), pantsMat);
            leftLeg.position.set(-0.15, -0.7, 0);
            const rightLeg = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.7, 0.3), pantsMat);
            rightLeg.position.set(0.15, -0.7, 0);
            const hoverboard = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.4, 0.1, 16), new THREE.MeshStandardMaterial({ color: 0xff00ff, emissive: 0xaa00aa, emissiveIntensity: 3, roughness: 0.3 }));
            hoverboard.rotation.x = Math.PI / 2;
            hoverboard.position.y = -1.05;
            hoverboard.visible = false;
            const playerLight = new THREE.PointLight(0x00ffff, 2, 15);
            playerLight.position.y = 2;
            player.add(headGroup, torso, leftArm, rightArm, leftLeg, rightLeg, hoverboard, playerLight);
            player.scale.set(1.2, 1.2, 1.2);
            player.position.set(lanes[currentLane], groundY, 5);
            scene.add(player);
            player.traverse(c => { if (c.isMesh) {c.castShadow = true; c.frustumCulled = false;} });
            playerBoundingBox = new THREE.Box3().setFromObject(player);
        }
        
        function createChaser() {
            chaser = new THREE.Group();
            const policeBlueMat = new THREE.MeshStandardMaterial({ color: 0x11116B, roughness: 0.6 });
            const blackMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.7 });
            const skinMat = new THREE.MeshStandardMaterial({ color: 0x8d5524, roughness: 0.8 });
            
            const torso = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.7, 0.3), policeBlueMat);
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.25), skinMat);
            head.position.y = 0.55;
            const cap = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 0.1, 16), policeBlueMat);
            cap.position.y = 0.7;
            const capBrim = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.05, 0.3), policeBlueMat);
            capBrim.position.set(0, 0.65, 0.15);
            const redLight = new THREE.Mesh(new THREE.SphereGeometry(0.05), new THREE.MeshBasicMaterial({color: 0xff0000}));
            redLight.position.y = 0.2;
            torso.add(redLight);
            const leftLeg = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.7, 0.2), blackMat);
            leftLeg.position.set(-0.15, -0.7, 0);
            const rightLeg = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.7, 0.2), blackMat);
            rightLeg.position.set(0.15, -0.7, 0);
            chaser.add(torso, head, cap, capBrim, leftLeg, rightLeg);
            chaser.position.set(player.position.x, groundY, player.position.z + 8);
            chaser.visible = false;
            scene.add(chaser);
        }

        function spawnWave() {
            const lane = Math.floor(Math.random() * 3);
            const type = Math.random();
            if (type < 0.35) createObstacle(lane, 1.8, 0.9);
            else if (type < 0.55) createObstacle(lane, 4, 2, 0.3);
            else if (type < 0.7) createTrain(lane, -120);
            else if (type < 0.85) createSlowdownPatch(lane);
            else if (type < 0.98) for(let i = 0; i < 5; i++) createCollectible(lane, -120 - i * 4);
        }
        
        function createObstacle(lane, height, yPos, width = 3.2) {
            const mat = new THREE.MeshStandardMaterial({ color: 0xff4444, roughness: 0.6 });
            const obstacle = new THREE.Mesh(new THREE.BoxGeometry(width, height, 1.5), mat);
            obstacle.castShadow = true;
            obstacle.position.set(lanes[lane], yPos, -120);
            scene.add(obstacle);
            obstacles.push(obstacle);
        }
        
        function createSlowdownPatch(lane) {
            const mat = new THREE.MeshStandardMaterial({ color: 0x654321, transparent: true, opacity: 0.8 });
            const patch = new THREE.Mesh(new THREE.PlaneGeometry(3.2, 5), mat);
            patch.rotation.x = -Math.PI / 2;
            patch.position.set(lanes[lane], 0.01, -120);
            scene.add(patch);
            slowdownPatches.push(patch);
        }

        function createTrain(lane, zPos) {
            const trainLength = 25;
            const mat = new THREE.MeshStandardMaterial({ color: 0xffff00, roughness: 0.5 });
            const train = new THREE.Mesh(new THREE.BoxGeometry(3.2, 4, trainLength), mat);
            train.castShadow = true;
            train.position.set(lanes[lane], 2, zPos - trainLength / 2);
            scene.add(train);
            obstacles.push(train);
        }

        function createCollectible(lane, zPos) {
            const mat = new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0xccad00, metalness: 0.5, roughness: 0.2, emissiveIntensity: 1.5 });
            const coin = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 0.15, 16), mat);
            coin.rotation.x = Math.PI / 2;
            coin.position.set(lanes[lane], 1.5, zPos);
            scene.add(coin);
            collectibles.push(coin);
        }
        
        function createCrystal(side) {
            const crystalGroup = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({
                color: 0x00ffff, emissive: 0x00eeee, transparent: true, opacity: 0.7, roughness: 0.3
            });
            const mainCrystal = new THREE.Mesh(new THREE.CylinderGeometry(0, 0.8, 4, 6), mat);
            mainCrystal.position.y = 2;
            crystalGroup.add(mainCrystal);
            for(let i = 0; i < 5; i++){
                const shard = new THREE.Mesh(new THREE.IcosahedronGeometry(Math.random()*0.5 + 0.2, 0), mat);
                shard.position.set(Math.random()*2-1, Math.random()*2-1, Math.random()*2-1);
                crystalGroup.add(shard);
            }
            crystalGroup.position.set(side * (10 + Math.random() * 10), 0, -120);
            scene.add(crystalGroup);
            sceneryObjects.push(crystalGroup);
        }

        function createScenery() {
             const side = Math.random() < 0.5 ? -1 : 1;
             const type = Math.random();
             if (type < 0.25) { // Streetlight
                // implementation from previous version
             } else if (type < 0.6) { // Crystal
                createCrystal(side);
             } else { // Tree
                 const trunkMat = new THREE.MeshLambertMaterial({color: 0x5c3c1c});
                 const leavesMat = new THREE.MeshLambertMaterial({color: 0x1c441c});
                 const tree = new THREE.Group();
                 const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, 3, 8), trunkMat);
                 const leaves = new THREE.Mesh(new THREE.ConeGeometry(2, 4, 8), leavesMat);
                 leaves.position.y = 3.5;
                 tree.add(trunk, leaves);
                 tree.position.set(side * (10 + Math.random() * 10), 1.5, -120);
                 tree.traverse(c => {if (c.isMesh) c.castShadow = true;});
                 scene.add(tree);
                 sceneryObjects.push(tree);
             }
        }

        function handleKeyDown(event) {
            if (!isGameRunning) return;
            if (event.code === 'ArrowLeft' && currentLane > 0) currentLane--;
            else if (event.code === 'ArrowRight' && currentLane < 2) currentLane++;
            else if ((event.code === 'ArrowUp' || event.code === 'Space') && !isJumping) jump();
            else if (event.code === 'ArrowDown' && !isJumping && !isRolling) roll();
            else if (event.code === 'KeyH') activateHoverboard();
        }

        function handleTouchStart(event) {
            event.preventDefault();
            touchStartX = event.touches[0].clientX;
            touchStartY = event.touches[0].clientY;
        }

        function handleTouchEnd(event) {
            if (!isGameRunning) return;
            const touchEndX = event.changedTouches[0].clientX;
            const touchEndY = event.changedTouches[0].clientY;
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            const currentTime = new Date().getTime();
            if (currentTime - lastTapTime < 300) activateHoverboard();
            lastTapTime = currentTime;
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                if (deltaX > 30 && currentLane < 2) currentLane++;
                else if (deltaX < -30 && currentLane > 0) currentLane--;
            } else {
                if (deltaY > 30 && !isJumping && !isRolling) roll();
                else if (deltaY < -30 && !isJumping) jump();
            }
        }

        function jump() { isJumping = true; playerVelocityY = jumpStrength; }
        function roll() { isRolling = true; rollTimer = 0.8; }

        function activateHoverboard() {
            if (isHoverboardActive || hoverboardCount <= 0) return;
            hoverboardCount--;
            updateHoverboardUI();
            isHoverboardActive = true;
            hoverboardTimer = 10.0;
            player.children[player.children.length - 2].visible = true;
        }

        function updateHoverboardUI() {
            document.getElementById('hoverboard-count').textContent = `Hoverboards: ${hoverboardCount}`;
        }

        function updateCollisions() {
            if (isHoverboardActive) return;
            playerBoundingBox.setFromObject(player);
            for (let i = obstacles.length - 1; i >= 0; i--) {
                if (playerBoundingBox.intersectsBox(new THREE.Box3().setFromObject(obstacles[i]))) {
                    endGame(); return;
                }
            }
            for (let i = slowdownPatches.length - 1; i >= 0; i--) {
                const patch = slowdownPatches[i];
                if (player.position.z > patch.position.z - 2.5 && player.position.z < patch.position.z + 2.5 && Math.abs(player.position.x - patch.position.x) < 1.6) {
                    if(!isSlowed) {
                        isSlowed = true;
                        slowdownTimer = 2.0;
                    }
                }
            }
            for (let i = collectibles.length - 1; i >= 0; i--) {
                const coin = collectibles[i];
                if(player.position.distanceTo(coin.position) < 2) {
                    scoreMultiplier++;
                    document.getElementById('multiplier').textContent = `x${scoreMultiplier}`;
                    scene.remove(coin);
                    collectibles.splice(i, 1);
                }
            }
        }
        
        let spawnTimer = 0;
        let sceneryTimer = 0;
        
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            if (stars) {
                stars.rotation.y += 0.00005;
                const colors = stars.geometry.attributes.color;
                const count = colors.count;
                for (let i = 0; i < count; i++) {
                    const randomFactor = Math.sin(i * 1.1 + time * (0.5 + (i % 10) / 20.0));
                    const brightness = THREE.MathUtils.mapLinear(randomFactor, -1, 1, 0.4, 1.0);
                    colors.setXYZ(i, brightness, brightness, brightness);
                }
                colors.needsUpdate = true;
            }

            if(isIntroAnimating) {
                introAnimationTime += delta;
                const progress = Math.min(introAnimationTime / 2.0, 1.0);
                player.rotation.y = Math.PI * progress;
                const startPos = new THREE.Vector3(0, player.position.y, player.position.z + 3);
                const endPos = new THREE.Vector3(0, 6, 14);
                camera.position.lerpVectors(startPos, endPos, progress);
                camera.lookAt(player.position.x, player.position.y, player.position.z);
                chaser.visible = true; // Chaser is visible during intro
                if (progress >= 1.0) {
                    isIntroAnimating = false;
                    isGameRunning = true;
                    chaser.visible = false; // Hide chaser after intro
                    document.getElementById('ui-container').style.opacity = '1';
                }
            }

            if (isGameRunning) {
                // Camera smoothly follows the player's position
                const cameraOffset = new THREE.Vector3(0, 5, 9);
                const cameraPosition = player.position.clone().add(cameraOffset);
                camera.position.lerp(cameraPosition, 0.1);
                camera.lookAt(player.position);


                if (isSlowed) {
                    slowdownTimer -= delta;
                    if (slowdownTimer <= 0) isSlowed = false;
                }
                chaser.visible = isSlowed; // Chaser is only visible when player is slowed
                const effectiveGameSpeed = isSlowed ? gameSpeed * 0.5 : gameSpeed;
                const moveZ = effectiveGameSpeed * 100 * delta;
                const targetX = lanes[currentLane];
                player.position.x += (targetX - player.position.x) * 0.2;
                if (isJumping) {
                    player.position.y += playerVelocityY;
                    playerVelocityY += gravity;
                    if (player.position.y <= groundY) {
                        player.position.y = groundY;
                        isJumping = false;
                    }
                }
                if (isRolling) {
                    rollTimer -= delta;
                    player.scale.y = 0.6;
                    if(rollTimer <= 0) { isRolling = false; player.scale.y = 1.2; }
                }
                const animTime = time * 10 * (effectiveGameSpeed / 0.2);
                const runningMotion = Math.sin(animTime) * 0.7;
                player.children[2].rotation.x = -runningMotion;
                player.children[3].rotation.x = runningMotion;
                player.children[4].rotation.x = runningMotion;
                player.children[5].rotation.x = -runningMotion;
                chaser.children[4].rotation.x = runningMotion;
                chaser.children[5].rotation.x = -runningMotion;
                if(isHoverboardActive) {
                    hoverboardTimer -= delta;
                    player.position.y = groundY + 0.15 + Math.sin(time * 15) * 0.05;
                    const statusEl = document.getElementById('hoverboard-status');
                    statusEl.style.display = 'block';
                    statusEl.textContent = `Invincible: ${Math.ceil(hoverboardTimer)}s`;
                    if(hoverboardTimer <= 0) {
                        isHoverboardActive = false;
                        player.children[player.children.length - 2].visible = false;
                        statusEl.style.display = 'none';
                        player.position.y = groundY;
                    }
                }
                const chaserTargetZ = isSlowed ? player.position.z + 2 : player.position.z + 6; 
                const chaserCatchUpSpeed = isSlowed ? 0.2 : 0.12; 
                chaser.position.z += (chaserTargetZ - chaser.position.z) * chaserCatchUpSpeed;
                chaser.position.x += (player.position.x - chaser.position.x) * 0.1;
                if (isGameRunning && chaser.position.z - player.position.z < 1.5) {
                    endGame();
                }
                trackSegments.forEach(seg => {
                    seg.position.z += moveZ;
                    if(seg.position.z > 100) seg.position.z -= 250;
                });
                [...obstacles, ...collectibles, ...sceneryObjects, ...slowdownPatches].forEach(obj => {
                    obj.position.z += moveZ;
                    if (obj.position.z > 20) {
                        scene.remove(obj);
                        obj.traverse(c => {
                            if(c.geometry) c.geometry.dispose();
                            if(c.material) c.material.dispose();
                        });
                        const arrays = [obstacles, collectibles, sceneryObjects, slowdownPatches];
                        arrays.forEach(arr => {
                           const index = arr.indexOf(obj);
                           if (index > -1) arr.splice(index, 1);
                        });
                    }
                });
                collectibles.forEach(c => c.rotation.y += delta * 5);
                spawnTimer -= delta;
                if (spawnTimer <= 0) {
                     spawnWave();
                     spawnTimer = 2.0 / (gameSpeed / 0.2);
                }
                sceneryTimer -= delta;
                if(sceneryTimer <= 0) {
                    createScenery();
                    sceneryTimer = 0.8 / (gameSpeed/0.2);
                }
                score += Math.floor((1 * scoreMultiplier) * (effectiveGameSpeed / 0.2));
                document.getElementById('score').textContent = `Score: ${score}`;
                gameSpeed += 0.0001;
                updateCollisions();
            }
            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function startGame() {
            if(isGameRunning || isIntroAnimating) return;
            document.getElementById('start-screen').style.display = 'none';
            introAnimationTime = 0;
            isIntroAnimating = true;
        }
        
        function resetCameraToIntro() {
             player.rotation.y = 0;
             camera.position.set(0, player.position.y, player.position.z + 3);
             camera.lookAt(player.position);
        }

        function endGame() {
            if (!isGameRunning) return;
            isGameRunning = false;
            document.getElementById('final-score').textContent = `Your Score: ${score}`;
            document.getElementById('game-over-screen').style.display = 'flex';
            document.getElementById('ui-container').style.opacity = '0';
        }

        function restartGame() {
            score = 0;
            scoreMultiplier = 1;
            gameSpeed = 0.2;
            currentLane = 1;
            player.position.set(lanes[currentLane], groundY, 5);
            chaser.position.set(player.position.x, groundY, player.position.z + 8);
            playerVelocityY = 0;
            isJumping = isRolling = isHoverboardActive = isIntroAnimating = isSlowed = false;
            slowdownTimer = 0;
            hoverboardCount = 3;
            updateHoverboardUI();
            player.scale.y = 1.2;
            player.children[player.children.length - 2].visible = false;
            document.getElementById('hoverboard-status').style.display = 'none';
            document.getElementById('score').textContent = `Score: 0`;
            document.getElementById('multiplier').textContent = `x1`;
            [...obstacles, ...collectibles, ...sceneryObjects, ...slowdownPatches].forEach(obj => scene.remove(obj));
            obstacles = []; collectibles = []; sceneryObjects = []; slowdownPatches = [];
            document.getElementById('game-over-screen').style.display = 'none';
            resetCameraToIntro();
            startGame();
        }
        init();
    </script>
</body>
</html>

